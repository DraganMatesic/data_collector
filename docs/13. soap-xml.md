[← Back to index](1.%20index.md)

# SOAP & XML Webservice Integration

**Implementation Status:** IN DEVELOPMENT | **Work Package:** WP-12 | **Milestone:** v0.5.0

## Overview

WSDL-based client for consuming SOAP/XML government and enterprise web services. Many European government data sources expose SOAP webservices (bank account registries, business registries, VAT validation, court record systems).

Built from the ground up based on enterprise experience with government SOAP APIs across multiple countries.

## SOAP Client

### Request Class SOAP Integration

SOAP calls flow through the Request class — same as REST. The Request class provides two SOAP methods that handle Zeep transport setup, error tracking (`ExceptionDescriptor`), counters (`RequestMetrics`), and abort logic (`should_abort()`):

| Method | Purpose |
|--------|---------|
| `create_soap_client(wsdl_url, **kwargs)` | Creates a Zeep `Client` wired through the Request's session (proxy, auth, timeout inherited). Returns `zeep.Client`. |
| `soap_call(service_method, **params)` | Wraps a Zeep service call with the same try/except/counter logic as `get()` and `post()`. Returns the Zeep result object. |

```python
from data_collector.utilities.request import Request

req = Request(timeout=60, retries=3)
req.set_proxy(proxy_config)

# Create client — proxy, auth, timeout flow through automatically
client = req.create_soap_client("https://api.example.com/service?wsdl")

# Call service — tracked by ExceptionDescriptor, counters, RequestMetrics
result = req.soap_call(client.service.GetCompanyInfo, registration_number="12345678")
```

> **Note:** Zeep fetches and parses the WSDL on `Client()` instantiation. Since the client is typically created once in `__init__()` and reused for all calls, WSDL is fetched once per run.

**What `soap_call()` handles internally:**
- Catches `zeep.exceptions.Fault`, `Timeout`, `ConnectionError`, `TransportError`
- Records errors in `ExceptionDescriptor` (same as `get()`/`post()`)
- Increments counters in `RequestMetrics` (timing, status codes, error types)
- `should_abort()` works after SOAP calls — same as REST

> **Proxy & Transport:** Proxy, auth, and timeout configuration set on the Request class flows through to SOAP calls automatically — see [4.4. request.md](4.4.%20request.md) and [15. proxy.md](15.%20proxy.md).

### Authentication Methods

| Method | Implementation |
|--------|---------------|
| **Basic Auth** | `req.set_auth(username, password)` — flows through session |
| **WS-Security** | `req.create_soap_client(wsdl_url, wsse=UsernameToken("user", "pass"))` |
| **Client certificate** | `req.session.cert = ("/path/to/cert.pem", "/path/to/key.pem")` |
| **API Key** | Custom SOAP header element via `zeep.xsd.Element` |

```python
# WS-Security example — passed as kwarg to create_soap_client
from zeep.wsse.username import UsernameToken

client = req.create_soap_client(
    wsdl_url,
    wsse=UsernameToken("username", "password")
)
```

### Request / Response Envelope

SOAP requests are XML envelopes:

```xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
    <soapenv:Header/>
    <soapenv:Body>
        <GetCompanyInfo>
            <registrationNumber>12345678</registrationNumber>
        </GetCompanyInfo>
    </soapenv:Body>
</soapenv:Envelope>
```

### Error Handling

`soap_call()` handles all SOAP errors through the Request class pipeline — same as `get()` and `post()`. No manual try/except needed in app code:

| Error Type | Request Class Handling |
|------------|----------------------|
| `zeep.exceptions.Fault` | SOAP-level fault — logged in `ExceptionDescriptor`, counter incremented |
| `requests.exceptions.Timeout` | Network timeout — retry logic, `ExceptionDescriptor`, `should_abort()` evaluates |
| `requests.exceptions.ConnectionError` | Service unreachable — `ExceptionDescriptor`, `should_abort()` evaluates |
| `zeep.exceptions.TransportError` | HTTP error (4xx/5xx) — logged, counter incremented |
| `lxml.etree.XMLSyntaxError` | Malformed XML response — logged, skip record |
| `defusedxml.common.DTDForbidden` | DTD processing blocked — malicious XML detected, skip record |
| `defusedxml.common.EntitiesForbidden` | External entity blocked — potential XXE attack, skip record |

For cases where app-specific SOAP fault handling is needed (e.g., specific fault codes), use `soap_call()` with the `raise_faults=True` option:

```python
from zeep.exceptions import Fault

try:
    result = self.request.soap_call(
        self.soap_client.service.GetAccountsByOIB,
        raise_faults=True,
        oib=company.oib
    )
except Fault as e:
    if e.code == "INVALID_OIB":
        self.logger.info("Invalid OIB, archiving", oib=company.oib)
        # App-specific handling
        continue
    raise  # Re-raise unexpected faults → Request class handles them
```

## Integration with BaseScraper

SOAP apps follow the same 3-file convention (`main.py`, `parser.py`, `tables.py`) and BaseScraper lifecycle. The SOAP client is created via the Request class in `__init__()` and called via `soap_call()` in `collect()`:

```python
# Planned file path: data_collector/country/financials/bank_accounts/main.py
from data_collector.scraping import BaseScraper
from data_collector.utilities.hashing import bulk_hash
from data_collector.country.financials.bank_accounts.parser import Parser
from data_collector.country.financials.bank_accounts.tables import BankAccounts

class BankAccountRegistry(BaseScraper):
    """Fetch bank account data from FINA's SOAP webservice."""

    base_url = "https://ws.fina.hr/iban/service?wsdl"

    def __init__(self, database, **kwargs):
        super().__init__(database, **kwargs)
        self.parser = Parser()
        self.soap_client = self.request.create_soap_client(self.base_url)

    def prepare_list(self):
        """Fetch company OIBs that need bank account lookup."""
        with self.database.create_session() as session:
            self.work_list = self.database.query(
                session, BankAccounts,
                filters=and_(
                    BankAccounts.archive == None,
                    BankAccounts.date_checked < self.threshold
                )
            )

    def collect(self):
        """Call SOAP service for each company."""
        for company in self.work_list:
            result = self.request.soap_call(
                self.soap_client.service.GetAccountsByOIB,
                oib=company.oib
            )

            if self.request.should_abort(self.logger, proxy_on=False):
                break

            if result is None:
                self.failed += 1
                continue

            records = self.parser.parse_account_response(result, company.oib)
            self.store(records)
            self.solved += 1

    def store(self, records):
        bulk_hash(records)
        with self.database.create_session() as session:
            self.database.merge(records, session)
```

## XML Processing

### Secure Parsing with defusedxml

Raw `lxml.etree.fromstring()` is vulnerable to XXE (XML External Entity) injection, billion laughs attacks, and DTD retrieval. Always use `defusedxml` for parsing untrusted XML from external sources:

```python
from defusedxml.lxml import fromstring

root = fromstring(xml_bytes)
companies = root.findall(".//Company", namespaces=ns_map)
for company in companies:
    name = company.find("Name", namespaces=ns_map).text
    reg_number = company.find("RegNumber", namespaces=ns_map).text
```

`defusedxml` wraps lxml with secure defaults — disables external entity resolution, DTD loading, and network access during parsing. Same API as `lxml.etree`, drop-in replacement.

> **Rule:** Never use `lxml.etree.fromstring()` or `xml.etree.ElementTree.fromstring()` on data from external sources. Always use `defusedxml` equivalents.

### Namespace Handling

Government SOAP APIs often use complex namespace hierarchies:

```python
ns_map = {
    "soap": "http://schemas.xmlsoap.org/soap/envelope/",
    "ns1": "http://example.com/registry/v2",
    "ns2": "http://example.com/common/types"
}
```

### Zeep Response Objects vs Raw XML

Zeep automatically deserializes SOAP responses into Python objects. Use these directly instead of parsing raw XML:

```python
# Zeep returns Python objects — no manual XML parsing needed
result = req.soap_call(client.service.GetCompanyInfo, registration_number="12345678")
company_name = result.Name        # Direct attribute access
status = result.Status.Code       # Nested objects
accounts = result.BankAccounts    # Lists become Python lists

# For complex types, serialize to dict for storage:
from zeep.helpers import serialize_object
data = serialize_object(result)   # Returns OrderedDict
```

Use raw `lxml` parsing only when:
- The service returns raw XML (not through Zeep)
- You need to extract data from XML stored in database BLOB columns
- The WSDL is unavailable and you're sending/receiving raw envelopes

## Integration Patterns

| Pattern | Description |
|---------|-------------|
| **WSDL caching** | `req.create_soap_client(wsdl_url, cache=True)` — only needed if client is created per iteration instead of once in `__init__()` |
| **Retry with backoff** | Handled by the `Request` class transport layer |
| **Response logging** | Enable `logging.getLogger("zeep.transports").setLevel(DEBUG)` for full XML |
| **Local WSDL** | `req.create_soap_client("/path/to/service.wsdl")` — when remote WSDL is unreliable |
| **Batch requests** | Some services support multi-record queries — call once per batch |
| **Async SOAP** | `AsyncTransport(client=req.async_client)` — available when Request class adds async httpx support (WP-02) |

## Dependencies

- **zeep** — SOAP client with WSDL support
- **defusedxml** — Secure XML parsing (XXE protection)
- **lxml** — XML parser backend (already in dependencies)
- **Request class** ([4.4. request.md](4.4.%20request.md)) — HTTP transport via `requests.Session`
- Proxy management ([15. proxy.md](15.%20proxy.md)) — proxy flows through session to Zeep


