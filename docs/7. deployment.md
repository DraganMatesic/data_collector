[← Back to index](1.%20index.md)

# Table Deployment

## Deploy Class <a id="deploy-class"></a>

**Source:** `data_collector/tables/deploy.py`

The `Deploy` class manages framework database schema creation and codebook seeding.

```python
from data_collector.tables.deploy import Deploy

api = Deploy()
```

On initialization, it connects to the database configured by `MainDatabaseSettings()`.

### Methods

| Method | Description |
|--------|-------------|
| `create_tables()` | Creates all tables defined in `Base.metadata` |
| `drop_tables()` | Drops all tables defined in `Base.metadata` |
| `recreate_tables()` | Drops then creates all tables (**destructive**) |
| `populate_tables()` | Seeds codebook tables with reference data |

## Deployment Steps

### Step 1: Configure Environment Variables

Set the required database connection variables:

```bash
# Required
DC_DB_MAIN_USERNAME=myuser
DC_DB_MAIN_PASSWORD=mypassword
DC_DB_MAIN_DATABASENAME=data_collector
DC_DB_MAIN_IP=localhost
DC_DB_MAIN_PORT=5432

# Optional
DC_DB_MAIN_SERVERNAME=myserver
```

### Step 2: Create Tables

```python
from data_collector.tables.deploy import Deploy

api = Deploy()
api.create_tables()
```

This creates all framework tables:
- `app_groups`, `app_parents`, `apps`, `app_db_objects`
- `runtime`, `c_runtime_codes`
- `logs`, `c_log_level`
- `c_cmd_flags`, `c_cmd_list`, `c_fatal_flags`, `c_run_status`
- `example_table`

### Step 3: Seed Codebook Data

```python
api.populate_tables()
```

This populates reference tables with predefined values using `Database.merge()` — ensuring codebook data matches the defined enums. The `delete` parameter controls whether orphaned rows are removed (see note below).

> **Seed data source:** All codebook preseed data is defined as Python `IntEnum`/`StrEnum` classes in `data_collector/enums/`. See [1.3. enums.md](1.3.%20enums.md) for the full enum reference.

> **Production warning:** Even though `merge(delete=True)` exists, it is **not recommended** once the framework is running in production and logs/runtime records are being stored regularly. Codebook tables (`c_log_level`, `c_run_status`, `c_cmd_flags`, etc.) are referenced by foreign keys from `logs`, `runtime`, and `apps`. Deleting a codebook row that is already referenced will either fail (FK constraint) or orphan historical data. **Always use `delete=False`** (the default) in production — this preserves all existing codes and only inserts new ones.

## Seed Data Reference

### Command Flags (`c_cmd_flags`)

| ID | Description |
|----|-------------|
| 0 | Command pending |
| 1 | Command Executed |
| 2 | Command not executed, conditions not meet |

### Command List (`c_cmd_list`)

| ID | Name | Description |
|----|------|-------------|
| 1 | start | Start app |
| 2 | stop | Stop app |
| 3 | restart | Restart app |
| 4 | enable | Enable app |
| 5 | disable | Disable app |

### Fatal Flags (`c_fatal_flags`)

| ID | Description |
|----|-------------|
| 1 | Failed to start |
| 2 | App stopped, alert sent |
| 3 | Unexpected behaviour |

### Run Status (`c_run_status`)

| ID | Description |
|----|-------------|
| 0 | App not running |
| 1 | App is running |
| 2 | App is stopped. Send command start or restart to start again. |

### Log Levels (`c_log_level`)

Populated dynamically from Python's `logging.getLevelNamesMapping()`:

| ID | Description |
|----|-------------|
| 0 | NOTSET |
| 10 | DEBUG |
| 20 | INFO |
| 30 | WARNING |
| 40 | ERROR |
| 50 | CRITICAL |

## Verification

After deployment, verify with SQL:

```sql
-- Check tables exist
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public'
ORDER BY table_name;

-- Check codebook data
SELECT * FROM c_cmd_list;
SELECT * FROM c_run_status;
SELECT * FROM c_log_level;
```

## Cross-Platform Deployment

Developed and tested primarily on Windows, but fully deployable on Linux including Docker containers and cloud environments.

## Production Considerations

> **Never use `recreate_tables()` in production.** It drops all tables and data.

For production environments:

1. Use `create_tables()` only for initial deployment — it's safe to call repeatedly (skips existing tables via `CREATE IF NOT EXISTS`).
2. Use `populate_tables()` after any codebook changes — use `delete=False` (default) to add new codes without removing existing ones. Only use `delete=True` on initial deployment or when you are certain no historical records reference the codes being removed.
3. For schema changes to existing tables, consider integrating **Alembic** for incremental migrations.
