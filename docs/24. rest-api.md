[← Back to index](1.%20index.md)

# REST API & Dashboard

**Implementation Status:** PLANNED | **Phase:** 5 (v0.5.0)

## Overview

A management API and real-time dashboard for controlling the Data Collector framework remotely. Provides REST endpoints for app management, monitoring, pipeline tracking, performance analysis, and notification management, plus a WebSocket-powered dashboard for live status updates.

## Technology Stack

| Component | Technology | Rationale |
|-----------|-----------|-----------|
| **API Framework** | FastAPI 0.110+ | Async-native, auto-generated OpenAPI docs, Pydantic integration |
| **WebSocket** | FastAPI WebSocket | Real-time dashboard updates, log streaming |
| **Authentication** | OAuth2 + JWT (PyJWT) | Industry standard, stateless tokens |
| **Dashboard** | Dash (Plotly) | Production-grade interactive dashboards, mounted inside FastAPI |
| **Database** | PostgreSQL / MSSQL | Framework-supported databases |
| **Task Queue** | Dramatiq + RabbitMQ | Distributed task processing |

## API Design

### Authentication & Authorization

Two authentication flows are supported:

**User Authentication (Dashboard, human operators):**
```
POST /api/v1/auth/token     → Get JWT access token (username + password)
POST /api/v1/auth/refresh   → Refresh expired token (one-time use, rotated)
```

**Service Authentication (Copilot Agent, automation):**
```
POST /api/v1/auth/service   → Get JWT via OAuth2 Client Credentials (client_id + client_secret)
```

Service clients (e.g., Teams Copilot Agent) authenticate with pre-registered credentials. For Microsoft Teams integration, Azure Entra ID can serve as the identity provider.

Alternatively, simple API key authentication via `X-API-Key` header is supported for internal service-to-service calls where OAuth2 is unnecessary.

**JWT Token Structure:**
```json
{
  "sub": "user@example.com",
  "role": "operator",
  "type": "user",
  "exp": 1700000000,
  "iss": "data-collector",
  "jti": "unique-token-id"
}
```

The `jti` (JWT ID) claim enables token revocation — revoked token IDs are stored in a blacklist (database table or Redis) and checked on each request.

**Roles:**
| Role | Permissions |
|------|------------|
| `viewer` | Read-only access to status and logs |
| `operator` | Start/stop apps, view logs, trigger runs |
| `admin` | Full access including configuration changes |
| `service` | Scoped API access for automated clients (Copilot, webhooks) |

### App Management Endpoints

```
GET    /api/v1/apps                → List all apps (filterable)
GET    /api/v1/apps/{app_id}       → Get app details + status
POST   /api/v1/apps/{app_id}/start → Send START command
POST   /api/v1/apps/{app_id}/stop  → Send STOP command
POST   /api/v1/apps/{app_id}/reset → Reset fatal flag
PATCH  /api/v1/apps/{app_id}       → Update app configuration
```

**Example Response — `GET /api/v1/apps`:**
```json
{
  "items": [
    {
      "app": "scraper_company_registry",
      "group": "scrapers",
      "parent": "registry",
      "run_status": "IDLE",
      "command_flag": "NONE",
      "fatal_flag": "NO_FATAL",
      "next_run": "2025-01-15T08:00:00Z",
      "last_runtime": {
        "runtime": "20250115_073000_scraper_company_registry",
        "started": "2025-01-15T07:30:00Z",
        "ended": "2025-01-15T07:45:12Z",
        "status": "COMPLETED"
      }
    }
  ],
  "total": 72,
  "page": 1,
  "per_page": 20
}
```

### Runtime & Logging Endpoints

```
GET    /api/v1/runtimes                  → List recent runtimes
GET    /api/v1/runtimes/{runtime_id}     → Runtime details
GET    /api/v1/logs                      → Query logs (filterable)
GET    /api/v1/logs/stream               → WebSocket: live log stream
```

**Log Query Parameters:**
| Parameter | Type | Description |
|-----------|------|-------------|
| `app` | string | Filter by app name |
| `level` | string | Minimum log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) |
| `from` | datetime | Start of time range |
| `to` | datetime | End of time range |
| `search` | string | Full-text search in message |
| `limit` | int | Max results (default 100) |

### Pipeline Monitoring Endpoints

```
GET    /api/v1/pipelines/tasks              → List PipelineTask records (filterable by document_type, status, stage)
GET    /api/v1/pipelines/tasks/{task_id}    → Get task details (current stage, errors, retry count)
GET    /api/v1/pipelines/throughput         → Pipeline throughput metrics (documents/hour by type, success/failure rates)
GET    /api/v1/pipelines/errors             → Recent pipeline errors grouped by document type
```

**Example Response — `GET /api/v1/pipelines/throughput`:**
```json
{
  "period": "last_24h",
  "pipelines": [
    {
      "document_type": "company_registration",
      "total_tasks": 142,
      "completed": 138,
      "failed": 4,
      "avg_duration_seconds": 12.3,
      "throughput_per_hour": 5.9
    }
  ]
}
```

### FunctionLog Query Endpoints

```
GET    /api/v1/performance/functions              → List FunctionLog entries (filterable by app, function_name, date range)
GET    /api/v1/performance/functions/slowest       → Top N slowest functions across all apps
GET    /api/v1/performance/functions/{app_id}      → Function performance history for a specific app
GET    /api/v1/performance/functions/trends         → Performance trends over time (task_size, solved, failed per function)
```

**Example Response — `GET /api/v1/performance/functions/slowest`:**
```json
{
  "items": [
    {
      "function_name": "process_records",
      "app_id": "scraper_company_registry",
      "avg_runtime_seconds": 45.2,
      "max_runtime_seconds": 120.8,
      "avg_task_size": 1500,
      "total_calls": 312
    }
  ]
}
```

### Notification System Management Endpoints

```
GET    /api/v1/notifications/channels          → List configured notification channels
POST   /api/v1/notifications/channels          → Add notification channel (Telegram, email, webhook, etc.)
PATCH  /api/v1/notifications/channels/{id}     → Update channel configuration
DELETE /api/v1/notifications/channels/{id}      → Remove notification channel
GET    /api/v1/notifications/history            → Recent notification history
POST   /api/v1/notifications/test/{channel_id} → Send test notification
```

### System Endpoints

```
GET    /api/v1/system/health        → Health check
GET    /api/v1/system/metrics       → System metrics (CPU, memory, disk)
GET    /api/v1/system/config        → Current configuration (redacted secrets)
POST   /api/v1/system/config        → Update configuration (admin only)
```

**Health Check Response:**
```json
{
  "status": "healthy",
  "version": "0.5.0",
  "uptime_seconds": 86400,
  "checks": {
    "database": {"status": "up", "latency_ms": 12},
    "rabbitmq": {"status": "up", "latency_ms": 5},
    "disk_usage_pct": 42.3
  }
}
```

### Bulk Operations

```
POST   /api/v1/bulk/start           → Start multiple apps
POST   /api/v1/bulk/stop            → Stop multiple apps
POST   /api/v1/bulk/command         → Send command to app group
```

**Example — Bulk Start:**
```json
{
  "filter": {
    "group": "scrapers",
    "parent": "registry"
  },
  "command": "START"
}
```

## WebSocket API

### Live Dashboard Feed

```
WS /api/v1/ws/dashboard
```

Sends JSON messages for real-time updates:

```json
{
  "type": "app.status_changed",
  "timestamp": "2025-01-15T07:30:00Z",
  "data": {
    "app": "scraper_company_registry",
    "old_status": "IDLE",
    "new_status": "RUNNING"
  }
}
```

**Message Types:**
| Type | Description |
|------|-------------|
| `app.status_changed` | App run status changed |
| `app.command_sent` | Command dispatched to app |
| `app.fatal` | App entered fatal state |
| `runtime.started` | New runtime created |
| `runtime.completed` | Runtime finished |
| `log.entry` | New log record (filtered by subscription) |
| `system.metric` | Periodic system metrics update |
| `pipeline.task_updated` | PipelineTask stage/status changed |

### Log Streaming

```
WS /api/v1/ws/logs?app=scraper_*&level=WARNING
```

Subscribes to filtered log stream. Supports glob patterns for app names.

## Dashboard

Dashboard design references were used during drafting and are intentionally not stored in this repository. The dashboard section below is the authoritative implementation specification.

### Approach: Dash Mounted Inside FastAPI

Dash (by Plotly) is mounted as WSGI middleware inside the FastAPI process — single deployment, single port, shared authentication. Uses `dash-ag-grid` for enterprise data tables and `dcc.Interval` for automatic refresh (3–5 seconds) without page reload.

```python
from fastapi import FastAPI
from fastapi.middleware.wsgi import WSGIMiddleware
from dash import Dash, html, dcc

api = FastAPI()

dash_app = Dash(__name__, requests_pathname_prefix="/dashboard/")
dash_app.layout = html.Div([
    dcc.Interval(id="auto-refresh", interval=3000),  # 3s live refresh
    # Sidebar + main content layout
])

api.mount("/dashboard", WSGIMiddleware(dash_app.server))
```

### Sidebar Navigation

| Section | Filters |
|---------|---------|
| **Program Manager** | All, Running, by group (dynamic from `Apps.group`), Disabled, Fatal, Services, Errors |
| **Statistics** | Runtime charts, performance trends, throughput |
| **Data Processor** | Pipeline status, NER/OCR processing views |

### Program Manager View — App Table

Sortable, filterable, multi-select data table (`dash-ag-grid`) with columns:

| Column | Source | Description |
|--------|--------|-------------|
| App ID | `Apps.id` | Unique app identifier |
| Group name | `Apps.group` | App group (country or functional) |
| Parent name | `Apps.parent` | Parent app/module |
| App name | `Apps.app` | Application name |
| Last run | `Runtime.started` | Last runtime start timestamp |
| Next run | `Apps.next_run` | Scheduled next execution |
| Run status | `Apps.run_status` | Current status (RunStatus enum) |
| Progress | `Apps` (live) / `FunctionLog` (historical) | Current/total items (e.g., `986/3000`, `40959/376869`) |
| ETA | Calculated | Estimated time to completion based on throughput |
| Fatal flag | `Apps.fatal_flag` | Fatal state indicator (FatalFlag enum) |
| Disabled | `Apps.disabled` | Whether app is disabled |

**Bulk actions** — checkbox selection + action buttons (Enable, Disable, Start, Stop, Restart) map to `POST /api/v1/bulk/*` endpoints.

### App Detail View

Clicking an app row opens the detail panel:

- **Left panel** — all `Apps` table fields displayed as read-only form (app, group, parent, settings JSON, schedule, flags, etc.)
- **Right panel** — tabbed view:
  - **Logs** — `FunctionLog` and application logs for the last runtime, sortable table with: log date, module name, function name, core runtime, message, timestamp
  - **History** — recent runtimes with duration, status, record counts
  - **Performance** — function execution trends, task_size over time

### Real-Time Updates

No page refresh required. Two mechanisms:

| Mechanism | Use Case | Latency |
|-----------|----------|---------|
| `dcc.Interval` (polling) | App table, progress column, status updates | 3–5 seconds |
| WebSocket push | Log streaming, live error alerts | Instant |

The `dcc.Interval` component triggers Dash callbacks every 3 seconds, which query the REST API and update the table in-place. The Progress column (`986/3000`) updates automatically as apps process records. WebSocket is used for the log viewer panel where instant updates are critical.

## Architecture

```
Clients
├── Browser ──────────────┐
├── Teams Copilot Agent ──┤
└── Automation scripts ───┘
              │
              ▼
      Reverse Proxy / API Gateway (HTTPS termination, WAF, rate limiting)
              │
              ▼
      FastAPI Server (port 8000)
      ├── /api/v1/*        REST endpoints
      ├── /api/v1/ws/*     WebSocket handlers
      ├── /dashboard/*     Dash UI (mounted WSGI)
      ├── JWT + API key middleware
      │       │
      │       ▼
      ├── Database (Apps, Runtime, Logs, PipelineTask, FunctionLog)
      ├── RabbitMQ (publish commands to managers)
      ├── Token blacklist (Redis or DB table)
      └── Notification channels (Telegram, email, webhook)
```

### Deployment Options

| Option | Description |
|--------|-------------|
| **Standalone** | Separate process connecting to same database (recommended) |
| **Containerized** | Docker container with API + dashboard behind reverse proxy |

The **standalone** approach is recommended — it avoids coupling the API lifecycle to the Manager and allows independent scaling. Never expose FastAPI directly to the internet; always place behind a reverse proxy (Nginx, Caddy, or cloud load balancer).

## FastAPI Application Structure

```
data_collector/
└── api/
    ├── __init__.py
    ├── main.py              # FastAPI app factory
    ├── config.py            # API-specific settings
    ├── dependencies.py      # Dependency injection (DB session, auth)
    ├── auth/
    │   ├── __init__.py
    │   ├── jwt.py           # Token creation/validation
    │   └── routes.py        # /auth/* endpoints
    ├── routes/
    │   ├── __init__.py
    │   ├── apps.py          # /apps/* endpoints
    │   ├── runtimes.py      # /runtimes/* endpoints
    │   ├── logs.py          # /logs/* endpoints
    │   ├── system.py        # /system/* endpoints
    │   ├── bulk.py          # /bulk/* endpoints
    │   ├── pipelines.py     # /pipelines/* endpoints
    │   ├── performance.py   # /performance/* endpoints (FunctionLog)
    │   └── notifications.py # /notifications/* endpoints
    ├── websocket/
    │   ├── __init__.py
    │   ├── dashboard.py     # Dashboard WebSocket handler
    │   └── logs.py          # Log streaming WebSocket handler
    └── schemas/
        ├── __init__.py
        ├── apps.py          # Pydantic response/request models
        ├── runtimes.py
        ├── logs.py
        ├── pipelines.py     # PipelineTask schemas
        ├── performance.py   # FunctionLog schemas
        └── notifications.py # Notification channel schemas
```

## Configuration

| Setting | Default | Description |
|---------|---------|-------------|
| `api_host` | `"0.0.0.0"` | API bind address |
| `api_port` | `8000` | API port |
| `api_workers` | `4` | Uvicorn worker count |
| `jwt_secret` | (required) | Secret key for JWT signing (RS256 private key in production) |
| `jwt_expiry_minutes` | `30` | Access token lifetime |
| `refresh_expiry_days` | `7` | Refresh token lifetime |
| `cors_origins` | `[]` | Allowed CORS origins (must be explicitly configured) |
| `api_key_header` | `"X-API-Key"` | Header name for API key authentication |
| `rate_limit_per_minute` | `100` | Per-IP request rate limit |
| `dashboard_enabled` | `true` | Enable Dash dashboard at `/dashboard` |

## Security Hardening

This API is designed for public domain exposure. All items below are mandatory for production deployment.

### Transport & Network

- **HTTPS only** — TLS termination at reverse proxy (Nginx/Caddy). HTTP requests redirected to HTTPS. HSTS header enforced.
- **Reverse proxy / API gateway** — never expose FastAPI directly. Nginx, Caddy, or cloud load balancer handles TLS, rate limiting, and request filtering.
- **WAF** — Web Application Firewall (cloud-native or ModSecurity) for OWASP Top 10 protection.
- **Request size limits** — max request body 10 MB (configurable). Prevents payload-based attacks.

### Authentication & Tokens

- **JWT access tokens** — short-lived (15–60 min). Signed with RS256 (asymmetric) for production, HS256 acceptable for internal-only deployments.
- **Refresh token rotation** — each refresh token is one-time use. On refresh, the old token is invalidated and a new pair (access + refresh) is issued.
- **Token revocation** — revoked `jti` values stored in blacklist (Redis with TTL matching token expiry, or database table with periodic cleanup). Checked on every authenticated request.
- **API keys** — hashed with Argon2 (via pwdlib) before storage. Transmitted only in `X-API-Key` header, never in URL query parameters.
- **Service credentials** — client_id + client_secret for OAuth2 Client Credentials flow. Secrets hashed, rotatable without downtime.

### Authorization

- **Role-based access control** — `viewer`, `operator`, `admin`, `service` roles enforced at endpoint level via FastAPI dependencies.
- **Principle of least privilege** — service accounts get scoped permissions (e.g., read-only for Copilot data queries, operator-level for command endpoints).

### Request Protection

- **CORS** — explicit origin allowlist. Never use `["*"]` in production. Configure per-environment.
- **CSRF protection** — required for dashboard (browser-based). FastAPI middleware or double-submit cookie pattern.
- **Rate limiting** — per-IP: 100 req/min general, 10 req/min on auth endpoints. Per-token: 1000 req/min. Use reverse proxy or `slowapi`.
- **Input validation** — all request bodies validated via Pydantic models. Query parameters type-checked and bounded.

### Response Security

- **Security headers** — applied via middleware:
  - `Strict-Transport-Security: max-age=31536000; includeSubDomains`
  - `X-Content-Type-Options: nosniff`
  - `X-Frame-Options: DENY`
  - `Content-Security-Policy: default-src 'self'`
  - `Referrer-Policy: strict-origin-when-cross-origin`
- **Secret redaction** — `/system/config` never exposes passwords, keys, or connection strings.
- **Health endpoint** — unauthenticated `/health` returns only `{"status": "healthy"}`. Version and component details require authentication.
- **Error responses** — never leak stack traces, SQL queries, or internal paths in production.

### Audit & Monitoring

- **Audit logging** — all write operations (POST/PATCH/DELETE) logged with: user/service identity, IP address, timestamp, endpoint, request summary, response status.
- **Failed auth logging** — failed login attempts logged with IP and timestamp for intrusion detection.
- **Log correlation** — each request assigned a unique `X-Request-ID` header, propagated through all downstream calls.

### WebSocket Security

- **Authentication** — WebSocket connections authenticate via JWT token sent in the first message after connection (not in query parameters, which appear in access logs).
- **Connection limits** — max concurrent WebSocket connections per user/IP.
- **Message validation** — all incoming WebSocket messages validated before processing.

## Dependencies

- **fastapi** — API framework (MIT)
- **uvicorn** — ASGI server (BSD-3-Clause)
- **PyJWT** — JWT token handling (MIT)
- **pwdlib** — password hashing with Argon2/bcrypt (MIT)
- **dash** — dashboard UI mounted inside FastAPI (MIT)
- **slowapi** — rate limiting middleware (MIT)
- Core framework tables (Apps, Runtime, Logs, PipelineTask, FunctionLog)
- [17. rabbitmq.md](17.%20rabbitmq.md) — command distribution
