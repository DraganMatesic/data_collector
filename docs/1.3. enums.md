[← Back to index](1.%20index.md)

# Enums

## Overview

Data Collector uses Python enums as the single source of truth for all constant values across the framework. Every integer flag, status code, command name, and categorical value is defined as an `IntEnum` or `StrEnum` — never as a magic number or hardcoded string.

Enums serve three purposes:

1. **Codebook seeding** — `Deploy.populate_tables()` reads enum members and populates codebook tables automatically
2. **Type-safe application code** — Queries, conditions, and comparisons use enum members instead of raw values
3. **Self-documenting** — Enum names describe intent; developers never need to guess what `status == 2` means

## Directory Structure

```
data_collector/enums/
├── __init__.py          # Re-exports all enums for convenience
├── commands.py          # CmdFlag, CmdName
├── runtime.py           # RunStatus, FatalFlag, RuntimeExitCode
├── logging.py           # LogLevel
├── database.py          # DbObjectType
├── hashing.py           # UnicodeForm
└── notifications.py     # AlertSeverity
```

Future enum files will be added as the framework grows (e.g., `http.py`, `pipeline.py`, `notifications.py`).

## Design Principles

### No Magic Numbers

Every numeric or string constant that carries business meaning must be an enum. This eliminates:
- Hardcoded integers in queries (`WHERE status = 1`)
- String literals that can be misspelled (`"running"` vs `"Runnning"`)
- Ambiguous comparisons that require code comments to explain

```python
# Bad — what does 2 mean?
if app.run_status == 2:
    ...

# Good — self-documenting
from data_collector.enums import RunStatus
if app.run_status == RunStatus.STOPPED:
    ...
```

### IntEnum vs StrEnum

| Type | Use when | DB column type | Example |
|------|----------|---------------|---------|
| `IntEnum` | Default for all codebook-backed constants | Integer | `RunStatus`, `LogLevel`, `CmdFlag`, `CmdName` |
| `StrEnum` | Value is a human-readable identifier (no codebook table) | String | Future use cases where string identity matters |

**Rule of thumb:** All codebook-backed enums use `IntEnum` — this enforces consistency across the schema and makes FK constraints uniform. Use `StrEnum` only for non-codebook constants where the string value is the identity (e.g., configuration keys).

### Forward-Only Growth

Enum values are never recycled. When a value becomes obsolete:
1. The corresponding codebook row is **archived** (soft-deleted via `archive` timestamp)
2. The enum member stays in code for backward compatibility with historical data
3. New values get new IDs — never reuse a deprecated ID

This ensures historical records always reference valid enum definitions, even after values are deprecated.

## Enum Definitions

### Runtime Enums (`enums/runtime.py`)

#### RunStatus

Tracks the current execution state of an application.

```python
class RunStatus(IntEnum):
    NOT_RUNNING = 0    # App is idle
    RUNNING = 1        # App is currently executing
    STOPPED = 2        # App was stopped (by command or error)
```

**Used by:** `Apps.run_status` → FK to `c_run_status`

#### FatalFlag

Indicates why an application was flagged as fatally failed and disabled.

```python
class FatalFlag(IntEnum):
    FAILED_TO_START = 1           # App could not start (dependency/config error)
    APP_STOPPED_ALERT_SENT = 2    # App stopped unexpectedly, alert was sent
    UNEXPECTED_BEHAVIOUR = 3      # App exhibited abnormal behavior
```

**Used by:** `Apps.fatal_flag` → FK to `c_fatal_flags`

#### RuntimeExitCode

Defines how and why an application's runtime cycle ended.

```python
class RuntimeExitCode(IntEnum):
    FINISHED = 0        # App finished jobs and exited normally
    MANAGER_EXIT = 1    # App terminated because manager is exiting
    ORPHAN_PID = 2      # App terminated (has PID list but no running status)
    CMD_DISABLE = 3     # App killed by user command: disable
    CMD_RESET = 4       # App killed by user command: reset
    CMD_STOP = 5        # App killed by user command: stop
    CMD_START = 6       # App killed by user command: start (restart cycle)
```

**Used by:** `Runtime.exit_code` → FK to `c_runtime_codes`

### Command Enums (`enums/commands.py`)

#### CmdFlag

Tracks the lifecycle state of a command issued to an application.

```python
class CmdFlag(IntEnum):
    PENDING = 0         # Command issued, not yet processed
    EXECUTED = 1        # Command processed successfully
    NOT_EXECUTED = 2    # Command could not be executed (conditions not met)
```

**Used by:** `Apps.cmd_flag` → FK to `c_cmd_flags`, `CommandLog.cmd_flag`

#### CmdName

Defines the available commands that can be issued to applications via the orchestration manager.

```python
class CmdName(IntEnum):
    START = 1           # Start the application
    STOP = 2            # Stop the application gracefully
    RESTART = 3         # Stop then start
    ENABLE = 4          # Re-enable a disabled application
    DISABLE = 5         # Disable the application (prevents scheduling)
```

**Used by:** `Apps.cmd_name` → FK to `c_cmd_list`, `CommandLog.cmd_name`

### Logging Enums (`enums/logging.py`)

#### LogLevel

Maps Python's standard logging levels. Used to store and query log severity in the database.

```python
class LogLevel(IntEnum):
    NOTSET = 0
    DEBUG = 10
    INFO = 20
    WARNING = 30
    ERROR = 40
    CRITICAL = 50
```

**Used by:** `Logs.log_level` → FK to `c_log_level`

### Database Enums (`enums/database.py`)

#### DbObjectType

Classifies database objects for structured routine execution via `DbExecutable` and dependency tracking in `AppDbObjects`.

```python
class DbObjectType(IntEnum):
    PROCEDURE = 1       # Stored procedure
    FUNCTION = 2        # Database function
```

**Used by:** `DbExecutable.object_type` (see [4.1. database.md](4.1.%20database.md#database-execute)), `AppDbObjects.object_type`

### Hashing Enums (`enums/hashing.py`)

#### UnicodeForm

Defines the Unicode normalization form applied to string values before hashing. Values map directly to `unicodedata.normalize()` form names.

```python
class UnicodeForm(StrEnum):
    NFC  = 'NFC'    # Canonical decomposition → canonical composition (default)
    NFD  = 'NFD'    # Canonical decomposition
    NFKC = 'NFKC'   # Compatibility decomposition → canonical composition
    NFKD = 'NFKD'   # Compatibility decomposition
```

**Used by:** `UnicodeParams.form` (see [4.2. hashing.md](4.2.%20hashing.md#supporting-types))

**Why `StrEnum`?** The string value _is_ the identity — it's passed directly to `unicodedata.normalize()`. No codebook table needed.

### Notification Enums (`enums/notifications.py`)

#### AlertSeverity

Defines the severity level for notifications sent through the pluggable notification system.

```python
class AlertSeverity(IntEnum):
    INFO = 1        # Informational messages (daily summaries, status updates)
    WARNING = 2     # Non-critical issues that may require attention
    ERROR = 3       # Failures that need operator action
    CRITICAL = 4    # Fatal errors requiring immediate intervention
```

**Used by:** `Notification.severity` (see [18. notifications.md](18.%20notifications.md))

## Usage Patterns

### In Queries — Type-Safe Filtering

```python
from data_collector.enums import RunStatus, FatalFlag, LogLevel

# Find all running apps
running = session.query(Apps).filter(Apps.run_status == RunStatus.RUNNING).all()

# Find apps with fatal errors
fatal = session.query(Apps).filter(Apps.fatal_flag == FatalFlag.UNEXPECTED_BEHAVIOUR).all()

# Get error-level logs for a specific runtime
errors = session.query(Logs).filter(
    Logs.runtime == runtime_id,
    Logs.log_level >= LogLevel.ERROR
).all()
```

### In Application Logic — Readable Conditions

```python
from data_collector.enums import CmdFlag, CmdName

# Check if a command is pending
if app.cmd_flag == CmdFlag.PENDING and app.cmd_name == CmdName.STOP:  # 0 and 2
    stop_application(app)
    app.cmd_flag = CmdFlag.EXECUTED
```

### In Codebook Seeding — Automatic Deployment

```python
# Deploy reads enum classes and populates codebook tables
deploy = Deploy(database)
deploy.populate_tables()

# Under the hood, for each enum → codebook mapping:
# 1. Reads all enum members
# 2. Generates rows: {id: member.value, description: member.name}
# 3. Computes SHA hash for each row
# 4. Runs merge() — inserts new, archives removed, skips unchanged
```

### In Comparisons — Integer-Compatible

Because `IntEnum` inherits from `int`, enum members work directly in numeric comparisons and SQLAlchemy filters without casting:

```python
# These are equivalent
app.exit_code == RuntimeExitCode.FINISHED  # enum comparison
app.exit_code == 0                          # int comparison (avoid this)

# Range comparisons work naturally
if log.log_level >= LogLevel.WARNING:
    alert(log.msg)
```

## Codebook ↔ Enum Mapping

Each enum class maps to exactly one codebook table:

| Enum Class | Codebook Table | ID Type | Notes |
|-----------|----------------|---------|-------|
| `RunStatus` | `c_run_status` | IntEnum | App execution state |
| `FatalFlag` | `c_fatal_flags` | IntEnum | Fatal error classification |
| `CmdFlag` | `c_cmd_flags` | IntEnum | Command lifecycle state |
| `CmdName` | `c_cmd_list` | IntEnum | Command identifiers |
| `RuntimeExitCode` | `c_runtime_codes` | IntEnum | Why a runtime cycle ended |
| `LogLevel` | `c_log_level` | IntEnum | Python logging levels |
| `AlertSeverity` | `c_alert_severity` | IntEnum | Notification severity level |
| `DbObjectType` | — (no codebook) | IntEnum | Used in `DbExecutable`, not stored as codebook |
| `UnicodeForm` | — (no codebook) | StrEnum | Unicode normalization form for `UnicodeParams` |

All codebook enums are `IntEnum`, ensuring uniform FK constraints (`id` → `id`) across the entire schema. `DbObjectType` and `UnicodeForm` are non-codebook enums — they're used for structured configuration, not database seeding.

## Adding New Enums

When adding a new enum to the framework:

1. **Choose the right type** — `IntEnum` for flags/codes/levels, `StrEnum` for human-readable identifiers
2. **Create or extend an enum file** in `data_collector/enums/`
3. **Re-export** from `__init__.py`
4. **Create the codebook table** in `data_collector/tables/` following the codebook standard (id, description, sha, archive, date_created)
5. **Register the mapping** in `Deploy` so `populate_tables()` seeds it automatically
6. **Add FK constraints** from data tables to the new codebook
7. **Never reuse values** — deprecated members stay in code, their codebook rows get archived

### Example: Adding a Pipeline Status Enum

```python
# Planned module path: data_collector/enums/pipeline.py
from enum import IntEnum

class PipelineStatus(IntEnum):
    PENDING = 0
    IN_PROGRESS = 1
    COMPLETED = 2
    FAILED = 3
    RETRY = 4
```

Then create the codebook table, register with Deploy, and use in `PipelineTask.status`:

```python
from data_collector.enums import PipelineStatus

# In queries
stuck = session.query(PipelineTask).filter(
    PipelineTask.status == PipelineStatus.FAILED
).all()
```

## Future Enum Groups

As the framework grows, new enum files will be added:

| File | Enums | Purpose |
|------|-------|---------|
| `pipeline.py` | `PipelineStatus`, `PipelineStage` | Document processing pipeline states |
| `http.py` | `RequestMethod`, `RetryStrategy` | HTTP request configuration |
| `notifications.py` | `ChannelType` | Notification channel classification |
| `database.py` | `ServerType` | Database server classification (extends existing `DbObjectType`) |

These will follow the same pattern: define in `enums/`, create codebook table, register with Deploy, use in application code.
