[â† Back to index](1.%20index.md)

# Secret Loader

`data_collector/secret_loader.py` is intended for developer machines where environment variables must be provisioned locally rather than through long-lived CI/CD runtime configuration.

The script extracts an encrypted `secrets.env.enc` artifact, decrypts it, and writes variables permanently at user scope.

## Behavior

- Downloads secrets from GitHub Actions as an encrypted artifact
- Decrypts content with AES-256-CBC using `DC_SECRET_PASSWORD`
- Writes variables at user scope:
  - Windows: `HKEY_CURRENT_USER\Environment`
  - Linux/macOS: shell profile file (for example `~/.bashrc`)

## When to Use

Use this workflow when:

- Development is performed on a local workstation
- Secrets must remain private to the developer environment
- Repository workflows should not auto-provision local machine variables

## Setup and Usage

### 1. Clone repository

```bash
git clone https://github.com/your-username/your-forked-repo.git
```

### 2. Set up environment

```bash
python -m venv .venv
source .venv/bin/activate      # Linux/macOS
.venv\Scripts\activate         # Windows
pip install -r requirements.txt
```

### 3. Configure repository secrets in your fork

- Open `Settings -> Secrets and variables -> Actions`
- Add required secrets for your environment
- Add `DC_SECRET_PASSWORD` (used for encryption/decryption)

### 4. Enable workflows

- Open the `Actions` tab in your fork
- Enable workflows if prompted

### 5. Configure export workflow

- Open `.github/workflows/secrets_expo.yml`
- Add `echo` lines for each secret that should be exported

```yaml
run: |
  echo "DB_USER=${{ secrets.DB_USER }}" >> secrets.env
  echo "DB_PASS=${{ secrets.DB_PASS }}" >> secrets.env
  echo "API_KEY=${{ secrets.API_KEY }}" >> secrets.env
```

### 6. Run export workflow

- Trigger workflow: `Export GitHub Secrets to AES-Encrypted ENV`
- Download artifact: `env-secrets-encrypted`
- Extract file: `secrets.env.enc`

### 7. Decrypt and apply locally

Set the artifact path in `data_collector/secret_loader.py` if needed, then run:

```bash
python -m data_collector.secret_loader
```

The script will use `DC_SECRET_PASSWORD` from environment, or prompt for it if missing.

## Requirements

- Python package: `cryptography`

## Operational Notes

- Windows environment changes are visible in new terminal sessions after broadcast
- Linux/macOS shell profile changes require a new shell session or profile reload
- Forked repositories do not inherit upstream secrets and must define their own

## Troubleshooting

If variables are not available after execution:

- Verify decryption password
- Verify the correct artifact was downloaded and extracted
- Restart terminal/IDE session
