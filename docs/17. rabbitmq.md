[← Back to index](1.%20index.md)

# RabbitMQ Integration

**Phase:** 4 (v0.4.0)

## Overview

RabbitMQ provides reliable, asynchronous **command distribution** across manager instances via `pika`. When a command is issued (from API, dashboard, or another manager), it is published to a RabbitMQ exchange and consumed by the target manager instance.

RabbitMQ also serves as the message broker for Dramatiq task processing workers — see [17.1. dramatiq.md](17.1.%20dramatiq.md) for pipeline task queues, worker patterns, and retry handling.

**Dependencies:** `pika`

Developed and tested primarily on Windows, but fully deployable on Linux.

## Architecture

### Command Distribution (pika)

```
  Command Source                     Manager Instance
  (API / Dashboard)                  (Consumer)
       │                                  │
       ▼                                  ▼
  Publish command ──► RabbitMQ ──► Consume command
  to exchange          Queue       from queue
       │                                  │
       ▼                                  ▼
  JSON message:                    Parse command
  {app_id, cmd,                    Execute on Apps table
   issued_by}                      Update cmd_flag
```

## Command Protocol

### Message Format
```json
{
    "app_id": "a1b2c3d4...",
    "command": 1,
    "issued_by": "admin@example.com",
    "timestamp": "2025-01-15T10:30:00Z",
    "args": {"company_id": "123456", "monitoring": true}
}
```

### Command Types

Maps to `CmdName` IntEnum (defined in `data_collector/enums/commands.py`, see [1.3. enums.md](1.3.%20enums.md)):

| Value | Name | Action |
|-------|------|--------|
| 1 | START | Start the application process |
| 2 | STOP | Gracefully stop the application |
| 3 | RESTART | Stop then start |
| 4 | ENABLE | Set `disable=False`, allow scheduling |
| 5 | DISABLE | Set `disable=True`, prevent scheduling |

### Command Flag (CmdFlag IntEnum)

| Value | Name | Meaning |
|-------|------|---------|
| 0 | PENDING | Command issued, not yet processed |
| 1 | EXECUTED | Command processed successfully |
| 2 | NOT_EXECUTED | Command could not be executed |

## Command Queue Topology

```
Exchange: dc_commands (direct)
    │
    ├── Queue: manager_1 (binding: manager_1)
    ├── Queue: manager_2 (binding: manager_2)
    └── Queue: broadcast (binding: all)
```

- **Per-manager queues:** Commands targeted to a specific manager instance
- **Broadcast queue:** Commands sent to all managers (e.g., "enable all apps")
- **Durable queues:** Messages survive RabbitMQ restarts

## Configuration

| Setting | Default | Description |
|---------|---------|-------------|
| `rabbit_host` | `localhost` | RabbitMQ server hostname |
| `rabbit_port` | `5672` | RabbitMQ AMQP port |
| `rabbit_username` | `guest` | RabbitMQ username |
| `rabbit_password` | `guest` | RabbitMQ password |
| `rabbit_queue` | `dc_manager` | Queue name for this manager |
| `rabbit_prefetch` | `1` | Messages to prefetch |

## Fallback

When RabbitMQ is unavailable, the manager falls back to **database polling** — checking the `Apps` table for pending commands directly. This ensures commands are never lost.

Pipeline tasks require RabbitMQ and do not have a DB-polling fallback — see [17.1. dramatiq.md](17.1.%20dramatiq.md).

## Dependencies

- **pika** — Python RabbitMQ client for command distribution
- Orchestration manager ([10. orchestration.md](10.%20orchestration.md))
- App arguments ([11. scraping.md](11.%20scraping.md)) — `args` dict in command payload flows to `init(runtime, args)`
- Dramatiq task processing ([17.1. dramatiq.md](17.1.%20dramatiq.md)) — uses RabbitMQ as its broker
