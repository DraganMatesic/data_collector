[← Back to index](1.%20index.md)

# @fun_watch Decorator & FunctionLog

**Implementation Status:** IN DEVELOPMENT | **Phase:** 4 (v0.4.0)

## Overview

The `@fun_watch` decorator provides automatic function-level performance monitoring for production use. It records execution metrics to the `FunctionLog` database table, creating a historical record of every function invocation across every runtime — including task volume, success/failure counts, and timing. Functions are auto-registered in the `AppFunctions` table on first invocation.

## Usage

```python
@fun_watch
def process_records(self, records):
    # Automatically tracked: execution time, task_size, solved/failed counts
    for record in records:
        self.parse(record)
        self.store(record)
```

## AppFunctions Table

Function registry populated automatically by `@fun_watch` on first invocation. See [1.2. data-model.md](1.2.%20data-model.md#appfunctions) for full column definitions.

| Column | Type | Description |
|--------|------|-------------|
| `id` | BigInteger (PK) | Auto-increment row identifier |
| `function_hash` | String(64) | Hash of (app_id + function_name) — stable function identity, UNIQUE |
| `function_name` | String(125) | Decorated function/method name |
| `filepath` | String(1024) | Module path where function is defined |
| `app_id` | String(64) (FK) | Owning application |
| `first_seen` | DateTime | First time this function was registered |
| `last_seen` | DateTime | Most recent invocation timestamp |

**Auto-registration:** The decorator computes `function_hash` from `sha256(app_id + function_name)` and checks an in-process cache (dict). On first invocation (cache miss), it upserts to `app_functions` and caches the hash. Subsequent calls within the same process skip the DB check entirely — zero overhead after first call.

## FunctionLog Table

Stores one row per decorated function invocation. Function metadata (name, filepath) lives in `AppFunctions`, not repeated here. See [1.2. data-model.md](1.2.%20data-model.md#functionlog) for full column definitions.

| Column | Type | Description |
|--------|------|-------------|
| `id` | BigInteger (PK) | Auto-increment row identifier |
| `function_hash` | String(64) (FK) | References `app_functions.function_hash` |
| `function_no` | Integer | Execution order within the app (per-thread) |
| `main_app` | String(64) | Hash of the root app |
| `app_id` | String(64) | Hash of app_group + app_parent + app_name |
| `thread_id` | Integer | Thread ID running this function instance |
| `task_size` | BigInteger | Number of items to process (input size) |
| `solved` | Integer | Number of items successfully processed (default: 0) |
| `failed` | Integer | Number of items that failed processing (default: 0) |
| `start_time` | DateTime | When the function began executing |
| `end_time` | DateTime | When the function finished executing |
| `totals` | Integer | Total execution time in seconds |
| `totalm` | Integer | Execution time in minutes |
| `totalh` | Integer | Execution time in hours |
| `runtime` | String(64) (FK) | Foreign key to Runtime table |

## How It Works

### Apps Table vs FunctionLog Table

These two tables serve complementary monitoring purposes:

| Aspect | Apps Table | FunctionLog Table |
|--------|-----------|-------------------|
| **Scope** | Current loop (live dashboard) | Every loop from every runtime (historical) |
| **Updates** | Overwritten each loop | Appended each loop (insert-only) |
| **Use case** | "What is the app doing right now?" | "How has this function performed over time?" |
| **Granularity** | App-level | Function-level |
| **Key metrics** | Current status, current function | task_size, solved, failed, duration per function |

### Decorator Behavior

When `@fun_watch` decorates a function, it:

1. Computes `function_hash` and auto-registers in `AppFunctions` (cached after first call)
2. Records `start_time` when the function begins
3. Captures `task_size` from the function's input (configurable attribute)
4. Tracks `solved` and `failed` counts during execution (closure-local variables)
5. Records `end_time` and computes `totals`, `totalm`, `totalh` when the function completes
6. Inserts a `FunctionLog` row linked to the current `runtime` and `function_hash`
7. Updates the `Apps` table with current function status (main thread only — see Thread Safety)
8. Updates `app_functions.last_seen` timestamp

```python
@fun_watch
def scrape_companies(self, companies):
    # task_size = len(companies) → recorded automatically
    for company in companies:
        try:
            self.fetch_and_store(company)
            # solved += 1
        except Exception:
            # failed += 1
            logger.error("Failed to process company", company_id=company.id)
```

## Thread Safety

The `@fun_watch` decorator is safe for use on methods called from multiple threads.

### Counters Are Closure-Local

Each invocation of a decorated function creates its own stack frame. The `solved`, `failed`, `start_time`, `end_time`, and `task_size` variables are local to the wrapper closure — not stored on `self` or any shared state. Multiple threads calling the same decorated method simultaneously get independent counters.

```python
def fun_watch(func):
    def wrapper(self, *args, **kwargs):
        start_time = datetime.now()    # local to this invocation
        solved = 0                      # local to this invocation
        failed = 0                      # local to this invocation
        # ... execute func ...
        # INSERT into FunctionLog with thread_id = threading.get_ident()
    return wrapper
```

### Per-Thread FunctionLog Rows

Each thread writes its own `FunctionLog` row with `thread_id` set to `threading.get_ident()`. The `function_no` ordinal is assigned per-thread within a runtime — thread A gets its own sequence, thread B gets its own.

### Apps Table Update — Main Thread Only

The `Apps` table update (step 7 — current function name, progress for the live dashboard) is performed **only by the main thread**. Threaded invocations skip this step to avoid race conditions where multiple threads overwrite each other's progress values. Thread-level progress is available via `FunctionLog` queries filtered by `thread_id`.

## Production Performance Monitoring

### Live Dashboard (Apps Table)

The Apps table shows **what each app is doing right now** — which function is running, current progress. This is refreshed every loop by the main thread.

### Function Inventory (AppFunctions)

The AppFunctions table provides a registry of all known functions:

```sql
-- All registered functions for a specific app
SELECT function_name, filepath, first_seen, last_seen
FROM app_functions
WHERE app_id = 'hash_of_app'
ORDER BY function_name;
```

### Historical Analysis (FunctionLog)

The FunctionLog table enables queries like:

```sql
-- Average runtime per function over the last 30 days
SELECT af.function_name, AVG(fl.totals) as avg_seconds, AVG(fl.task_size) as avg_items
FROM function_log fl
JOIN app_functions af ON fl.function_hash = af.function_hash
WHERE fl.start_time > NOW() - INTERVAL '30 days'
GROUP BY af.function_name
ORDER BY avg_seconds DESC;

-- Failure rate trends
SELECT af.function_name,
       SUM(fl.failed)::float / NULLIF(SUM(fl.task_size), 0) as failure_rate,
       DATE(fl.start_time) as day
FROM function_log fl
JOIN app_functions af ON fl.function_hash = af.function_hash
GROUP BY af.function_name, DATE(fl.start_time)
ORDER BY day DESC;

-- Identify performance degradation
SELECT af.function_name, DATE(fl.start_time) as day, AVG(fl.totals) as avg_seconds
FROM function_log fl
JOIN app_functions af ON fl.function_hash = af.function_hash
WHERE af.function_name = 'scrape_companies'
GROUP BY af.function_name, DATE(fl.start_time)
ORDER BY day;
```

## Local Profiling (Not a Framework Concern)

For **line-level profiling** during development (identifying which lines within a function are slow), developers should use standard Python profiling tools locally:

- **cProfile** — built-in function-level profiler
- **line_profiler** — third-party line-by-line profiler

These are development-time tools, not production monitoring. The framework focuses on production-grade function-level metrics via `@fun_watch` and `FunctionLog`.

## Dependencies

- Core Framework ([4.1. database.md](4.1.%20database.md), Runtime table)
- [1.2. data-model.md](1.2.%20data-model.md#function-tracking) — AppFunctions + FunctionLog table definitions
